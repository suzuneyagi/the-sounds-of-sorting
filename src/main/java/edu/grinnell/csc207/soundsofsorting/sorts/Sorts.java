package edu.grinnell.csc207.soundsofsorting.sorts;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;

import edu.grinnell.csc207.soundsofsorting.sortevents.SortEvent;
//import edu.grinnell.csc207.soundsofsorting.sortevents.SwapEvent;

/**
 * A collection of sorting algorithms.
 */
public class Sorts {
    /**
     * Swaps indices <code>i</code> and <code>j</code> of array <code>arr</code>.
     * @param <T> the carrier type of the array
     * @param arr the array to swap
     * @param i the first index to swap
     * @param j the second index to swap
     */
    public static <T> void swap(T[] arr, int i, int j) {
        T tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }

    /**
     * Sorts the array according to the bubble sort algorithm:
     * <pre>
     * [ unprocessed | i largest elements in order ]
     * </pre>
     * @param <T> the carrier type of the array
     * @param arr the array to sort
     * @return the sort events generated by this sort
     */
    public static <T extends Comparable<? super T>> List<SortEvent<Integer>> bubbleSort(T[] arr) {
        // I dont know how to use this 
        List<SortEvent<Integer>> events = new ArrayList<>();

        for (int j = arr.length - 1; j > 0; j--) {
            for (int i = 0; i < j; i++) {
                if (arr[i].compareTo(arr[i + 1]) > 0) {
                    swap(arr, i, i + 1);
                } 
            }
        }
        return null;
    }

    /**
     * Sorts the array according to the selection sort algorithm:
     * <pre>
     * [ i smallest elements in order | unprocessed ]
     * </pre>
     * @param <T> the carrier type of the array
     * @param arr the array to sort
     * @return the sort events generated by this sort
     */
    public static <T extends Comparable<? super T>> List<SortEvent<Integer>> selectionSort(
            T[] arr) {
                for (int j = 0; j < arr.length - 1; j++) {
                T min = arr[j];
                int minIndex = j;
                for (int i = j + 1; i < arr.length; i++) {
                    if (min.compareTo(arr[i]) > 0) {
                        min = arr[i];
                        minIndex = i;
                    }
                }
                swap(arr, j, minIndex);
            }
            return null;
    }

    /**
     * Sorts the array according to the insertion sort algorithm:
     * <pre>
     * [ i elements in order | unprocessed ] 
     * </pre>
     * @param <T> the carrier type of the array
     * @param arr the array to sort
     * @return the sort events generated by this sort
     */
    public static <T extends Comparable<? super T>> List<SortEvent<Integer>> insertionSort(
            T[] arr) {
                for (int i = 1; i < arr.length; i++) {
                    int j = i;
                    while (j > 0 && arr[j].compareTo(arr[j-1]) < 0) {
                        swap(arr, j, j-1);
                        j--;
                    }
                }
        return null;
    }

    /**
     * Sorts the array according to the merge sort algorithm.
     * @param <T> the carrier type of the array
     * @param arr the array to sort
     * @return the sort events generated by this sort
     */
    public static <T extends Comparable<? super T>> List<SortEvent<Integer>> mergeSort(
            T[] arr) {
        if (arr.length > 1) {
            int mid = arr.length / 2;
            T[] left = Arrays.copyOfRange(arr, 0, mid);
            T[] right = Arrays.copyOfRange(arr, mid, arr.length);
            mergeSort(left); 
            mergeSort(right);
            mergeHelper(arr, left, right);
        }
        return null;
    }

    public static <T extends Comparable<? super T>> void mergeHelper(T[] arr, T[] left, T[] right) {
        int leftIndex = 0;
        int rightIndex = 0;
        int counter = 0;
        while (leftIndex < left.length && rightIndex < right.length) {
            if (left[leftIndex].compareTo(right[rightIndex]) < 0) {
                arr[counter] = left[leftIndex];
                leftIndex++;
            } else {
                arr[counter] = right[rightIndex];
                rightIndex++;
            }
            counter++;
        }
        while (leftIndex < left.length) {
            arr[counter] = left[leftIndex];
            leftIndex++;
            counter++;
        }
        while (rightIndex < right.length) {
            arr[counter] = right[rightIndex];
            rightIndex++;
            counter++;
        }
    }

    /**
     * Sorts the array according to the quick sort algorithm.
     * @param <T> the carrier type of the array
     * @param arr the array to sort
     * @return the sort events generated by this sort
     */
    public static <T extends Comparable<? super T>> List<SortEvent<Integer>> quickSort(T[] arr) {
        quickSortHelper(arr, 0, arr.length - 1);
        return null;
    }

    private static <T extends Comparable<? super T>> void quickSortHelper(T[] arr, int start, int end) {
        if(end > start){
            int pivotIndex = partition(arr, start, end);
            quickSortHelper(arr, start, pivotIndex - 1);
            quickSortHelper(arr, pivotIndex + 1, end);
        }
    }

    private static <T extends Comparable<? super T>> int partition(T[] arr, int start, int end) {
        T pivot = arr[end];
        int i = start - 1;
        for (int j = start; j < end; j++) {
            if (arr[j].compareTo(pivot) < 0) {
                i++;
                swap(arr, i, j);
            }
        }
        i++;
        swap(arr, i, end);
        return i;
    }

    /**
     * Sorts the array according to the shell sort algorithm.
     * @param <T> the carrier type of the array
     * @param arr the array to sort
     * @return the sort events generated by this sort
     */
    public static <T extends Comparable<? super T>> List<SortEvent<Integer>> shellSort(
            T[] arr) {
                for (int gap = arr.length / 2; gap > 0; gap /= 2) {
                    for (int i =  gap; i < arr.length; i++) {
                        T temp = arr[i];
                        int j = i;
                        while (j >= gap && arr[j - gap].compareTo(temp) > 0) {
                            arr[j] = arr[j - gap];
                            j -= gap;
                        }
                    }
                }
                return null;
            }
}
