package edu.grinnell.csc207.soundsofsorting.sorts;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;

import edu.grinnell.csc207.soundsofsorting.sortevents.CompareEvent;
import edu.grinnell.csc207.soundsofsorting.sortevents.SwapEvent;
import edu.grinnell.csc207.soundsofsorting.sortevents.CopyEvent;
import edu.grinnell.csc207.soundsofsorting.sortevents.SortEvent;

/**
 * A collection of sorting algorithms.
 */
public class Sorts {
    /**
     * Swaps indices <code>i</code> and <code>j</code> of array <code>arr</code>.
     * @param <T> the carrier type of the array
     * @param arr the array to swap
     * @param i the first index to swap
     * @param j the second index to swap
     */
    public static <T> void swap(T[] arr, int i, int j) {
        T tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }

    /**
     * Sorts the array according to the bubble sort algorithm:
     * <pre>
     * [ unprocessed | i largest elements in order ]
     * </pre>
     * @param <T> the carrier type of the array
     * @param arr the array to sort
     * @return the sort events generated by this sort
     */
    public static <T extends Comparable<? super T>> List<SortEvent<T>> bubbleSort(T[] arr) {
        List<SortEvent<T>> events = new ArrayList<>();

        for (int j = arr.length - 1; j > 0; j--) {
            for (int i = 0; i < j; i++) {
                events.add(new CompareEvent<T>(i, i + 1));
                if (arr[i].compareTo(arr[i + 1]) > 0) {
                    events.add(new SwapEvent<T>(i, i + 1));
                    swap(arr, i, i + 1);
                } 
            }
        }
        return events;
    }

    /**
     * Sorts the array according to the selection sort algorithm:
     * <pre>
     * [ i smallest elements in order | unprocessed ]
     * </pre>
     * @param <T> the carrier type of the array
     * @param arr the array to sort
     * @return the sort events generated by this sort
     */
    public static <T extends Comparable<? super T>> List<SortEvent<T>> selectionSort(
            T[] arr) {
                List<SortEvent<T>> events = new ArrayList<>();

                for (int j = 0; j < arr.length - 1; j++) {
                    T min = arr[j];
                    int minIndex = j;
                    for (int i = j + 1; i < arr.length; i++) {
                        events.add(new CompareEvent<T>(minIndex, i));
                        if (min.compareTo(arr[i]) > 0) {
                            events.add(new CopyEvent<T>(min, j));
                            min = arr[i];
                            minIndex = i;
                        }
                    }
                    events.add(new SwapEvent<T>(j, minIndex));
                    swap(arr, j, minIndex);
                }
            return events;
    }

    /**
     * Sorts the array according to the insertion sort algorithm:
     * <pre>
     * [ i elements in order | unprocessed ] 
     * </pre>
     * @param <T> the carrier type of the array
     * @param arr the array to sort
     * @return the sort events generated by this sort
     */
    public static <T extends Comparable<? super T>> List<SortEvent<T>> insertionSort(
            T[] arr) {
                List<SortEvent<T>> events = new ArrayList<>();
                for (int i = 1; i < arr.length; i++) {
                    int j = i;
                    while (j > 0) {
                        events.add(new CompareEvent<T>(j, j - 1));
                        if (arr[j].compareTo(arr[j-1]) < 0) {
                            events.add(new SwapEvent<T>(j, j - 1));
                            swap(arr, j, j-1);
                            j--;
                        } else {
                            break;
                        }
                    }
                }
        return events;
    }

    /**
     * Sorts the array according to the merge sort algorithm.
     * @param <T> the carrier type of the array
     * @param arr the array to sort
     * @return the sort events generated by this sort
     */
    public static <T extends Comparable<? super T>> List<SortEvent<T>> mergeSort(
            T[] arr) {
                List<SortEvent<T>> events = new ArrayList<>();
                if (arr.length > 1) {
                    int mid = arr.length / 2;
                    T[] left = Arrays.copyOfRange(arr, 0, mid);
                    T[] right = Arrays.copyOfRange(arr, mid, arr.length);
                    mergeSort(left); 
                    mergeSort(right);
                    mergeHelper(arr, left, right, events);
                }
                return events;
    }

    public static <T extends Comparable<? super T>> void mergeHelper(T[] arr, T[] left, T[] right, List<SortEvent<T>> events) {
        int leftIndex = 0;
        int rightIndex = 0;
        int counter = 0;
        while (leftIndex < left.length && rightIndex < right.length) {
            events.add(new CompareEvent<T>(leftIndex, rightIndex));
            if (left[leftIndex].compareTo(right[rightIndex]) < 0) {
                events.add(new CopyEvent<T>(left[leftIndex], counter));
                arr[counter] = left[leftIndex];
                leftIndex++;
            } else {
                events.add(new CopyEvent<T>(right[rightIndex], counter));
                arr[counter] = right[rightIndex];
                rightIndex++;
            }
            counter++;
        }
        while (leftIndex < left.length) {
            events.add(new CopyEvent<T>(left[leftIndex], counter));
            arr[counter] = left[leftIndex];
            leftIndex++;
            counter++;
        }
        while (rightIndex < right.length) {
            events.add(new CopyEvent<T>(right[rightIndex], counter));
            arr[counter] = right[rightIndex];
            rightIndex++;
            counter++;
        }
    }

    /**
     * Sorts the array according to the quick sort algorithm.
     * @param <T> the carrier type of the array
     * @param arr the array to sort
     * @return the sort events generated by this sort
     */
    public static <T extends Comparable<? super T>> List<SortEvent<T>> quickSort(T[] arr) {
        List<SortEvent<T>> events = new ArrayList<>();
        quickSortHelper(arr, 0, arr.length - 1, events);
        return null;
    }

    private static <T extends Comparable<? super T>> void quickSortHelper(T[] arr, int start, int end, List<SortEvent<T>> events) {
        if(end > start){
            int pivotIndex = partition(arr, start, end, events);
            quickSortHelper(arr, start, pivotIndex - 1, events);
            quickSortHelper(arr, pivotIndex + 1, end, events);
        }
    }

    private static <T extends Comparable<? super T>> int partition(T[] arr, int start, int end, List<SortEvent<T>> events) {
        T pivot = arr[end];
        int i = start - 1;
        for (int j = start; j < end; j++) {
            events.add(new CompareEvent<>(j, end));
            if (arr[j].compareTo(pivot) < 0) {
                i++;
                events.add(new SwapEvent<>(i, j));
                swap(arr, i, j);
            }
        }
        i++;
        events.add(new SwapEvent<>(i, end));
        swap(arr, i, end);
        return i;
    }

    /**
     * Sorts the array according to the shell sort algorithm.
     * @param <T> the carrier type of the array
     * @param arr the array to sort
     * @return the sort events generated by this sort
     */
    public static <T extends Comparable<? super T>> List<SortEvent<T>> shellSort(
            T[] arr) {
                List<SortEvent<T>> events = new ArrayList<>();
                for (int gap = arr.length / 2; gap > 0; gap /= 2) {
                    for (int i =  gap; i < arr.length; i++) {
                        T temp = arr[i];
                        int j = i;
                        while (j >= gap) {
                            events.add(new CompareEvent<>(j - gap, i));
                            if (arr[j - gap].compareTo(temp) > 0) {
                                events.add(new CopyEvent<>(arr[j - gap], j));
                                arr[j] = arr[j - gap];
                                j -= gap;
                            } else {
                                break;
                            }
                        }
                    }
                }
                return events;
            }
}
